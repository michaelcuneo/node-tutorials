<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@600&family=Fira+Code&family=Open+Sans&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/javascript.min.js"></script>
  </head>
  <body>
    <div class="container">
      <a href="/tutorial_1">NPM Tutorial 1 - Hello World!</a>
      <a href="/tutorial_2">NPM Tutorial 2 - Reverse Proxy!</a>
      <a href="/tutorial_3">NPM Tutorial 3 - TBA</a>
      <h2>NPM Tutorial 3 - Reverse Proxy!</h2>
      <div class="steps">
        <h3>Intro</h3>
        <p>
          This tutorial will explain how to host a node.js service running
          privately on our own host halide.michaelcuneo.com.au behind a reverse
          Proxy.
        </p>
      </div>
      <div class="steps">
        <h3>Set up Apache with a new host.</h3>
        <p>Login to HALIDE via SSH to your local user account.</p>
        <p>Change directory to /etc/apache/sites-available</p>
        <p>
          Duplicate an existing site with cp and change all of the configuration
          to suit running a reverse proxy from Port 80 to Port 3000 on a node.js
          application. For this example I will be using the Reverse Proxy
          example to host this tutorial set.
        </p>
        <p>
          sudo cp 001-halide-michaelcuneo-com-au.conf
          009-node-michaelcuneo.com.au.conf
        </p>
        <p>
          Open up 009-node-michaelcuneo.com.au.conf and edit it to change all of
          the values to suit reverse proxying.
        </p>
        <p>
          You want to keep the Virtual Host receiving *:80, because you are
          listening to incoming connections on Port 80
        </p>
        <p>Server Admin is your own personal email.</p>
        <p>
          Server Name and Server Alias should both be set to the subdomain that
          you want to use under michaelcuneo.com.au ... or if you're setting
          this up for your own services, [appname].aidenbc.com.au
        </p>
        <p>
          Document Root can be removed because a node.JS does not have one... it
          manages this using it's own runtime services.
        </p>
        <p>
          Error Log and Custom log can be renamed to suit the service you're
          running for Customised dedicated logging.
        </p>
        <p>
          You want to add these three lines to the config to support reverse
          proxying. For this project I have used the port 3050 so that it
          doesn't interfere with my development that generally sits on 3000.
          ProxyPreserveHost On ProxyPass / http://localhost:3050/
          ProxyPassReverse / http://localhost:3050/
        </p>
        <p>
          You can also remove any rewrite conditions so that the resulting file
          looks something like this one that I made for this tutorial hosting.
          The Rewrite Conditions will be re-added later when Certbot does it
          business.
        </p>
        <p>
          After you have a site config completed you have to enable it with the
          following commands, a2ensite stands for Apache 2 Enable Site, and will
          copy the configuration to the sites-enabled folder and make it
          readable by Apache to launch when restarted. Then restart apache with
          the System Controller.
        </p>
        <p>sudo a2ensite example.com sudo systemctl restart apache2</p>
        <p>
          Because we want SSL support, we can easily add a new config that adds
          a VirtualHost listening on *:443 and provides Security Certificates
          with CERTBOT, but before we can do this we have to have the domain
          resolvable so we have to login to AWS and add a Route53 Subdomain for
          this app, so that when you hit node.michaelcuneo.com.au the Route53
          service sends the requests to the IP of the server,
          michaelcuneo.com.au or aidenbc.com.au.
        </p>
        <p>
          Before we login to Amazon we need to find out what the current IP of
          HALIDE is... using the same script that we use in the 'IP Update
          scripts' for our other domain endpoints. curl ifconfig.me
        </p>
        <p>
          Now that we have an IP to add to the Route53 Subdomain. We can login
          to AWS.
        </p>
        <p>
          After you're in to AWS search for Route53 up the top area, and you can
          get to Route53
        </p>
        <p>
          For our service you'll see that we have 7 hosted zones. If you click
          on Hosted Zones you'll see we have quite a few. You want to edit
          michaelcuneo.com.au or aidenbc.com.au
        </p>
        <p>
          I clicked on michaelcuneo.com.au and I have a lot of records... 28 to
          be exact... some are to route the MX mailservice to Google Mail, some
          are for projects, some are to validate that I own michaelcuneo.com.au
        </p>
        <p>To add a new subdoain just clicked Create Record</p>
        <p>
          Under subdomain this is where you write the name of the app like you
          did in the configuration for Apache, [appname].michaelcuneo.com.au or
          [appname].aidenbc.com.au
        </p>
        <p>
          You want the record type to be an A Record, and you want the value to
          be the IP that you got from the curl ifconfig.me command. This IP is
          currently 114.76.75.20. Every other setting you can leave default, and
          hit 'Create Record'
        </p>
        <p>
          If you wait about 30 seconds now... ping [appname].michaelcuneo.com.au
          or [appname].aidenbc.com.au should resolve to 114.76.75.20
        </p>
        <p>
          Now that the domain is resolving to the HALIDE server, we can use the
          Certbot to receive a valid SSL certification from the CERTBOT
          endpoint. Part of this validation requires that CERTBOT can see that
          we own the domain, and if the domain does not point to where we're
          running CERTBOT from it will deny the validation and we get no SSL.
        </p>
        <p>
          Getting a config for SSL over port *:443 is as simple as running sudo
          certbot, when you run Certbot you will see a list of domains that
          we're hosting on HALIDE, just type the number beside the domain that
          you have added to the apache service, hit enter, and everything else
          should be automatic, and you'll be gifted a brand new configuration by
          certbot for ssl. But again, like before, it won't be active yet,
          restart apache to allow it to read the new configuration for SSL. sudo
          systemctl restart apache2
        </p>
        <p>
          At this point if you go to [appname].michaelcuneo.com.au or
          [appname].aidenbc.com.au it should tell you that the service in
          unavailable because nothing is running on port 3050.
        </p>
      </div>
    </div>
    <!-- Entry Point for the Application -->
    <script type="module" src="./index.js"></script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>
